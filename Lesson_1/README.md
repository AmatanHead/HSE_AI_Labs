### Project creation

Create Third Person C++ project

### Pickup actor creation

In this section we will create basic class to represent pickups in our game.

Steps to create new actor:
* Create new C++ class called Pickup that is based on standard class Actor
* Open the code editor to implement the class
* Note UCLASS and GENERATED_BODY macros - they allow interaction between Code and UE4 Editor

Add boolean flat that signifies whether pickup is active

```c++
// Is true if pickup is active and false otherwise.
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Pickup)
bool bIsActive;
```

UPROPERTY allows us to use the field inside game editor and in blueprints:
* EditAnywhere - Indicates that this property can be edited via property windows, archetypes and instances within the Editor.
* BlueprintReadWrite - This property can be read or written from a blueprint.

Add sphere component that will handle collisions

```c++
// Component for handling collisions.
UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category = Pickup)
USphereComponent* BaseCollisionComponent;
```

* BlueprintReadOnly - This property can be read by blueprints, but not modified.

Add static mesh component that will represent pickup in real world

```c++
// Component that represents pickup in the real world.
UPROPERTY(VisibleDefaultsOnly, BlueprintReadOnly, Category = Pickup)
UStaticMeshComponent* PickupMesh;
```

* VisibleDefaultsOnly - Indicates that this property is only visible in property windows for archetypes, and cannot be edited.

Declare function that will be called on pick up
```c++
// Called when pickup is collected.
UFUNCTION(BlueprintNativeEvent)
void OnPickedUp();
```

* BlueprintNativeEvent - This function is designed to be overridden by a Blueprint, but also has a native implementation. Provide a body named [FunctionName]_Implementation instead of [FunctionName]; the autogenerated code will include a thunk that calls the implementation method when necessary.

Initialize pickup fields:
* Pickup should be active by default
* Create collision component and set the root component to it
* Create pickup mesh component, turn on physics for it, attach it to root component

```c++
// Sets default values
APickup::APickup()
{
    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
    PrimaryActorTick.bCanEverTick = true;

    // Pickup is active by default.
    bIsActive = true;

    // Create collision component.
    BaseCollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("RootComponent"));

    // Set collision component as a root component.
    RootComponent = BaseCollisionComponent;

    // Create pickup mesh component.
    PickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("PickupMesh"));

    // Turn on physics (e.g. gravity, collisions).
    PickupMesh->SetSimulatePhysics(true);

    // Attach mesh to root component.
    PickupMesh->SetupAttachment(RootComponent);
}
```

Implement OnPickedUp function

```c++
void APickup::OnPickedUp_Implementation()
{
    // There is no default behavior for Pickup base class.
}
```

Note the implementation suffix - it is a base implementation of the method that can be extended in blueprints.

### Battery class creation

In this section we will create battery pickup class that will represent powerup that can be collected by player to obtain energy.

Start by creating new C++ class BatteryPickup based on Pickup.

Implicitly declare public constructor to be able to change its implementation
```c++
public:
    ABatteryPickup();
```

Create PowerLevel field to represent battery power

```c++
// The ammount of power stored in the battery.
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Power)
float PoweLevel;
```

Override base class OnPickedUp method

```c++
// Override base class method implementation to customize the battery behavior.
void OnPickedUp_Implementation() override;
```

Initialize battery power level
```c++
ABatteryPickup::ABatteryPickup()
{
    // Set default power level for a battery.
    PowerLevel = 150.0f;
}
```

Override pickup implementation to destroy the battery after pickup
```c++
void ABatteryPickup::OnPickedUp_Implementation()
{
    // Call parent implementation.
    Super::OnPickedUp_Implementation();
    // Destroy the battery after pickup.
    Destroy();
}
```

### Enabling the character to collect pickups

In this section we will implement character pickup collection and implement battery effects.

First we start by adding a mapping for collecting a pickup. For this go to Edit -> Project settings -> Engine -> Input -> Bindings.
There you can see two types of mappings:
* Action Mapping - used for discrete events (e.g jumping)
* Axis Mapping - used for continous events (e.g. movement, camera direction)

Add new action mapping called CollectPickups and bind it to E key on keyboard.
More info: https://docs.unrealengine.com/latest/INT/Gameplay/Input/

Next we are going to implement pickups collection for our character.
All edits happen in file `Lesson_1Character.h`.
First we start with the public section of character interface.

To represent an area around character where pickups can be collected we add new component
```c++
// Virtual sphere around the characted that determines the pickups that can be collected now.
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Power)
USphereComponent* CollectionSphere;
```

We would also like to store current character power and speed
```c++
// Current power level of the character.
UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Power)
float PowerLevel;

// Degree of influence of power on the character speed.
UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Power)
float SpeedFactor;

// Base speed of the character.
UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = Power)
float BaseSpeed;
```

Finally, we need to override `Tick` function to control character speed when its power level changes
```c++
// Override the base function to implement character specific logic.
virtual void Tick(float DeltaSeconds) override;
```

Now we move to the private interface.

Lets declare a function that will be called when user invokes our `CollectPickups` mapping
```c++
// Collects all batteries that are in collection radius of the player.
UFUNCTION(BlueprintCallable, Category = Power)
void CollectBatteries();
```

To decouple batteries collection from the actual powerup we will use helper function that will be available from the blueprints
```c++
// Applies collected battery power to update character state.
UFUNCTION(BlueprintImplementableEvent, Category = Power)
void PowerUp(float BatteryPower);
```

We can now implement declared functions in `Lesson_1Character.cpp` file.

First we initialize default values for character properties in `ALesson_1Character` constructor
```c++
// Set initial power level of the character.
PowerLevel = 2000.0f;

// Set the power-speed multiplier and base speed of the character.
SpeedFactor = 0.75f;
BaseSpeed = 10.0f;
```

Then we create and attach the collection sphere to the root component of the character
```c++
// Create collection sphere and set it's default radius.
CollectionSphere = CreateDefaultSubobject<USphereComponent>(TEXT("CollectionSphere"));
CollectionSphere->SetupAttachment(RootComponent);
CollectionSphere->SetSphereRadius(200.0f);
```

We are finished with constructor and now move to `ALesson_1Character::SetupPlayerInputComponent` method to bind our `CollectPickups` mapping to actual method
```c++
// Bind CollectPickups key mapping to call CollectBatteries function.
InputComponent->BindAction("CollectPickups", IE_Pressed, this, &ALesson_1Character::CollectBatteries);
```

We implement our custom `Tick` method that will control character speed based on it's power level
```c++
void ALesson_1Character::Tick(float DeltaSeconds)
{
    Super::Tick(DeltaSeconds);

    // Character speed is bounded with BaseSpeed from below and linearly depends on the power level.
    GetCharacterMovement()->MaxWalkSpeed = SpeedFactor * PowerLevel + BaseSpeed;
}
```

The last but very important function that we need to implement is `CollectBatteries` that will
iterate over objects that are collectable by character (that overlap with `CollectionSphere`),
pick up all the neighboring batteries and apply their energy to power up the character
```c++
void ALesson_1Character::CollectBatteries()
{
    // Stores total collected power from one sweep of CollectBatteries call.
    float BatteryPower = 0.0f;

    // First we get all the actors that are close enough to the character (overlap with CollectionSphere).
    TArray<AActor*> CollectedActors;
    CollectionSphere->GetOverlappingActors(CollectedActors);
    for (int i = 0; i < CollectedActors.Num(); ++i) {
        // We iterate over every neighboring actor and check,
        // whether it is a battery and it is still active.
        auto* TestBattery = Cast<ABatteryPickup>(CollectedActors[i]);
        if (TestBattery && !TestBattery->IsPendingKill() && TestBattery->bIsActive) {
            // We found a battery and we collect it's power and deactivate it.
            BatteryPower += TestBattery->PowerLevel;
            TestBattery->bIsActive = false;
            TestBattery->OnPickedUp();
        }
    }

    // Finally, if we managed to collect anything, we power up the character by the collected ammount.
    if (BatteryPower > 0.0f) {
        PowerLevel += BatteryPower;
        PowerUp(BatteryPower);
    }
}
```

### Creating the batteries representation

Create new blueprint BP_BatteryPickup

Set static mesh to represent it. Use Rock for simplicity, later replace it with battery from ExampleContent project.
Change collision settings to overlap with World.

### Implementing spawn volume

In this section we will create a volume that will spawn batteries at random locations of the map.

### Implement game modes

In this section we will implement game modes: game will end when the player reaches zero energy level.
At this point spawning will stop and player camera will be freezed.

### Implement HUD

In this section we will implement text interface to display current power lowel and also show Game Over message in the end of the game.
