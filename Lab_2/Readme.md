#Лабораторная работа 2#

![Нотариально заверенный скриншот™](result.png?raw=true")

Итак, алгоритм выдает 500 заказов с 90-процентилем времени ожидания от 7 до 9.5 секунд в зависимости от настроек.

Идея не сильно отличается от того, что говорилось на лекции.

##Структура##

`StrategyManager` организует кооперативную стратегию и передает контроллерам ботов приказы.
Он же хранит настройки алгоритма.

`CollaborativeAIController` получает приказы от StrategyManager.

##Изменения##

К сожалению, я запустил замену табов на пробелы, из-за чего diff показывает много изменений.

На самом же деле вся новая логика лежит в классах `StrategyManager` и `CollaborativeAIController` (это новые файлы).

В остальных файлах были лишь минорные изменения.
Часть из них лежит в предыдущих коммитах (тот, что слит в основной репозиторий и еще один до него),
другая часть касается логирования.

Кроме того были изменены некоторые блюпринты. В частности, Character теперь рисует шар над тем домом, к которому бежит.

*UPD* Передвинул один дом и всех ботов, чтобы избежать проблем с навигацией.

##Алгоритм##

Для кождого здания, в котором есть заказы, и для каждого бота считаем score (функция из прошлой лабы),
после чего в образовавшемся двудольном графе берем минимальное ребро между ботом A и домом B,
добавляем в очередь бота A дом B, после этого берем минимальное ребро такое, что оно не ведет к дому B
и не отходит от бота A, добавляем его в очередь другого бота и т.д.

В результате у каждого бота есть дом. к которому мы и приказываем бежать этому боту.

На самом деле у бота получается очередь из домов (при текущем алгоритме в ней всегда не более одного дома).
Такой подход — для будущих модификаций. Изначально я планировал реализовать алгоритм генерации очереди
и алгоритм выбора следующего дома из очереди как отдельные функторы, чтобы
их можно было передавать в StrategyManager и тем самым менять его поведение,
однако из-за нехватки времени сделал всё в одном классе,
так что можно от него наследоваться и перегружать соответствующие функции.

Запускается алгоритм, изложенный выше, или каждый тик (но не чаще чем раз в x секунд),
или когда у какого-нибудь бота нет заказа.
Контролируется это поведение настройками `Recalculate Every Tick` (включить/отключить расчет на каждом тике)
и `Recalculate Delay` (сколько ждать между расчетами) класса StrategyManager (доступны из HUD).

Лучшее время алгоритм показывает при `RecalculateEveryTick = true; RecalculateDelay = 0.05`.
При этом если уменьшать `RecalculateDelay`, время выполнения уменьшается,
но увеличивается риск, что на каждом тике бот будет менять заказ (и вообще боты становятся дерганными).
Настройка `RecalculateEveryTick = false` эквивалентна настройке
`RecalculateEveryTick = true; RecalculateDelay = +inf` и работает с 90-процентилем, равным 9.5с.
Это самая плавная настройка (боты не дергаются), но и самая медленная.

##Известные ошибки##

Во-первых, уже привычный тупёж навигации. Эти ребята просто бегают в стенки и врезаются в углы =(
Если бы они так не делали, результаты были бы лучше
(к примеру, можно было бы увеличить Recalculate Delay без потери производительности).

Во-вторых, иногда игра падает с неправильным доступом к памяти, судя по логам, в районе физического движка.
Еще иногда AnimationController начинает говорить, что ему дали невалидный pawn.

Первое лечится перезапуском, второе — удалением персонажей с карты и добавлением их по новой
(после этого их нужно зарегистрировать в StrategyManager).

Не знаю, что вызывает эти баги. Я пробовал комментировать куски своего кода, эффекта не добился, так что это где-то глубже.
Похоже, проявляется всё это только после hot spot reload после компиляции.
Возможно, из-за динамической генерации уровня, во время процесса перезагрузки съезжают какие-то указатели.
